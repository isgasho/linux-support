// This file is part of file-descriptors. It is subject to the license terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/file-descriptors/master/COPYRIGHT. No part of file-descriptors, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
// Copyright Â© 2018-2019 The developers of file-descriptors. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/file-descriptors/master/COPYRIGHT.


/// Received signal information.
#[repr(C)]
#[derive(Default, Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct signalfd_siginfo
{
	/// Signal number.
	pub ssi_signo: u32,

	/// Error number (unused except for some events generated by the USB URBS device subsystem).
	pub ssi_errno: i32,

	/// Signal code.
	pub ssi_code: i32,

	/// PID of sender (for signals `SIGCHLD` and `sigqueue()`).
	pub ssi_pid: i32,

	/// Real UID of sender (for signals `SIGCHLD` and `sigqueue()`).
	pub ssi_uid: u32,

	/// File descriptor (for signal `SIGIO` (for `poll()`)).
	pub ssi_fd: i32,

	/// Kernel timer ID (for a POSIX timer signal).
	pub ssi_tid: u32,

	/// Band event (for signal `SIGIO` (for `poll()`)).
	pub ssi_band: u32,

	/// POSIX timer overrun count.
	pub ssi_overrun: u32,

	/// Trap number that caused signal.
	pub ssi_trapno: u32,

	/// Exit status or signal (for signal `SIGCHLD`).
	pub ssi_status: i32,

	/// Integer sent by `sigqueue()` and POSIX timers.
	pub ssi_int: i32,

	/// Pointer sent by `sigqueue()` and POSIX timers.
	pub ssi_ptr: u64,

	/// User CPU time consumed (for signal `SIGCHLD`).
	pub ssi_utime: u64,

	/// System CPU time consumed (for signal `SIGCHLD`).
	pub ssi_stime: u64,

	/// Address that generated signal (for hardware-generated signals).
	pub ssi_addr: u64,

	/// Least significant bit of address (for signal SIGBUS).
	///
	/// Since Linux 2.6.37.
	pub ssi_addr_lsb: u16,

	_pad2: u16,

	/// System call number.
	pub ssi_syscall: i32,

	/// System call address.
	pub ssi_call_addr: u64,

	/// System call architecture.
	pub ssi_arch: u32,

	_pad: [u8; 28],
}

impl signalfd_siginfo
{
	/// Handle a signal.
	#[inline(always)]
	pub fn handle_signal(&self, signal_handler: &impl SignalHandler) -> Result<(), ()>
	{
		#[cfg(any(target_arch = "mips64", target_arch = "sparc64"))] const SIGEMT: c_int = 7;

		const KernelRealtimeSignalUpperLimit: i32 = SIGRTMIN - 1;

		match self.ssi_signo as i32
		{
			SIGABRT =>
			{
				signal_handler.handle_sigabrt(self.generic());
				unsafe { raise(SIGKILL); }
				unreachable!()
			}

			SIGALRM => signal_handler.handle_sigalrm(self.generic()),

			SIGBUS => signal_handler.handle_sigbus(self.specific(BusFaultData::new)),

			SIGCHLD => signal_handler.handle_sigchld(self.specific(ChildData::new)),

			SIGCONT => signal_handler.handle_sigcont(self.generic()),

			#[cfg(any(target_arch = "mips64", target_arch = "sparc64"))] SIGEMT => signal_handler.handle_sigemt(self.specific(FaultData::new)),

			SIGFPE => signal_handler.handle_sigfpe(self.specific(FaultData::new)),

			SIGHUP => signal_handler.handle_sighup(self.generic()),

			SIGILL => signal_handler.handle_sigill(self.specific(FaultData::new)),

			SIGINT => signal_handler.handle_sigint(self.generic()),

			SIGIO => signal_handler.handle_sigio(self.specific(PollData::new)),

			SIGPIPE => signal_handler.handle_sigpipe(self.generic()),

			SIGPROF => signal_handler.handle_sigprof(self.generic()),

			SIGPWR => signal_handler.handle_sigpwr(self.generic()),

			SIGQUIT => signal_handler.handle_sigquit(self.generic()),

			SIGSEGV => signal_handler.handle_sigsegv(self.specific(FaultData::new)),

			SIGSTKFLT => signal_handler.handle_sigstkflt(self.generic()),

			SIGSYS => signal_handler.handle_sigsys(self.specific(SystemCallData::new)),

			SIGTERM => signal_handler.handle_sigterm(self.generic()),

			SIGTRAP => signal_handler.handle_sigtrap(self.specific(FaultData::new)),

			SIGTSTP => signal_handler.handle_sigtstp(self.generic()),

			SIGTTIN => signal_handler.handle_sigttin(self.generic()),

			SIGTTOU => signal_handler.handle_sigttou(self.generic()),

			SIGURG => signal_handler.handle_sigurg(self.generic()),

			SIGUSR1 => signal_handler.handle_sigusr1(self.generic()),

			SIGUSR2 => signal_handler.handle_sigusr2(self.generic()),

			SIGVTALRM => signal_handler.handle_sigvtalrm(self.generic()),

			SIGWINCH => signal_handler.handle_sigwinch(self.generic()),

			SIGXCPU => signal_handler.handle_sigxcpu(self.generic()),

			SIGXFSZ => signal_handler.handle_sigxfsz(self.generic()),

			signal_number @ SIGRTMIN_Kernel ..= KernelRealtimeSignalUpperLimit => signal_handler.handle_illegal_sigrt(signal_number as u32, self.generic()),

			// In theory, ssi_pid, ssi_uid, ssi_ptr and ssi_int should all be valid values... in practice, there is no g'tee of this.
			signal_number @ SIGRTMIN ..= SIGRTMAX => signal_handler.handle_sigrt(signal_number as u32, self.generic()),

			signal_number @ _ => signal_handler.handle_illegal_signal(signal_number as u32, self.generic()),
		}
	}

	#[inline(always)]
	fn generic(&self) -> GenericSignalData
	{
		use self::GenericSignalData::*;

		match self.ssi_code
		{
			SI_KERNEL => Private,

			SI_USER => User { pid: self.ssi_pid, uid: self.ssi_uid },

			SI_TKILL => TKill { pid: self.ssi_pid, uid: self.ssi_uid, },

			userspace if userspace < 0 => Userspace(UserspaceSignalCode::from_ssi_code(userspace)),

			_ => unreachable!(),
		}
	}

	#[inline(always)]
	fn specific<C: Code>(&self, extract_coded_data: impl FnOnce(&Self) -> C::Data) -> SpecificSignalData<C>
	{
		use self::SpecificSignalData::*;

		let code = self.ssi_code;

		if likely!(code >= 1 && code <= (C::InclusiveMaximum.into()))
		{
			Specific(extract_coded_data(self), C::convert(code))
		}
		else
		{
			Generic(self.generic())
		}
	}
}
